"use strict";(self.webpackChunkstreamlit_geomap_frontend=self.webpackChunkstreamlit_geomap_frontend||[]).push([[5011],{12536:(e,t,i)=>{i.d(t,{R:()=>Z});var n=i(89379),o=i(15941),r=i(63919),a=i(44680),s=i(34761),l=i(13191),c=i(19555),d=i(72745),u=i(20664),f=i(9392),p=i(55855);function h(e){return function(e){return e instanceof Float32Array&&e.length>=16}(e)||function(e){return Array.isArray(e)&&e.length>=16}(e)}var v=i(2413),g=i(88105),m=i(63048),A=i(22955),x=i(48549),S=i(34981),C=i(40318),b=i(61785),O=i(75803),P=i(45463),T=i(77730),E=i(12028),z=i(86994),y=i(66470);class I{constructor(){this.scale=0,this.factor=0,this.minScaleFactor=0}}var F=i(52757),R=i(99362),_=i(19061),w=i(16506),D=i(59246),H=i(72001),N=i(60322),j=i(93345),L=i(57162);class M extends D.w{constructor(e,t){super(e,t,new w.$(_.H,()=>i.e(271).then(i.bind(i,60271)))),this.primitiveType=t.occlusionPass?j.WR.POINTS:j.WR.TRIANGLES}initializePipeline(e){const{oitPass:t,hasPolygonOffset:i,draped:n,output:o,depthTestEnabled:r,occlusionPass:a}=e,s=t===H.Y.NONE,l=t===H.Y.ColorAlpha,c=o===S.V.Highlight,d=r&&!n&&!l&&!a&&!c;return(0,L.Ey)({blending:(0,S.RN)(o)?s?L.RC:(0,N.ez)(t):null,depthTest:r&&!n?{func:j.MT.LEQUAL}:null,depthWrite:d?L.Uy:null,drawBuffers:(0,N.m6)(t,o),colorWrite:L.kn,polygonOffset:i?V:null})}}const V={factor:0,units:-4};var U=i(35143),B=i(97808),W=i(42717),q=i(6485),Y=i(92656);class k extends Y.E{constructor(e){super(),this.spherical=e,this.screenCenterOffsetUnitsEnabled=!1,this.occlusionTestEnabled=!0,this.signedDistanceFieldEnabled=!1,this.sampleSignedDistanceFieldTexelCenter=!1,this.vvSize=!1,this.vvColor=!1,this.hasVerticalOffset=!1,this.hasScreenSizePerspective=!1,this.hasRotation=!1,this.debugDrawLabelBorder=!1,this.hasPolygonOffset=!1,this.depthTestEnabled=!0,this.pixelSnappingEnabled=!0,this.draped=!1,this.terrainDepthTest=!1,this.cullAboveTerrain=!1,this.occlusionPass=!1,this.occludedFragmentFade=!1,this.objectAndLayerIdColorInstanced=!1,this.horizonCullingEnabled=!0,this.isFocused=!0,this.textureCoordinateType=B.I.None,this.emissionSource=W.ZX.None,this.discardInvisibleFragments=!0,this.hasVvInstancing=!1,this.snowCover=!1}}(0,U._)([(0,q.W)()],k.prototype,"screenCenterOffsetUnitsEnabled",void 0),(0,U._)([(0,q.W)()],k.prototype,"occlusionTestEnabled",void 0),(0,U._)([(0,q.W)()],k.prototype,"signedDistanceFieldEnabled",void 0),(0,U._)([(0,q.W)()],k.prototype,"sampleSignedDistanceFieldTexelCenter",void 0),(0,U._)([(0,q.W)()],k.prototype,"vvSize",void 0),(0,U._)([(0,q.W)()],k.prototype,"vvColor",void 0),(0,U._)([(0,q.W)()],k.prototype,"hasVerticalOffset",void 0),(0,U._)([(0,q.W)()],k.prototype,"hasScreenSizePerspective",void 0),(0,U._)([(0,q.W)()],k.prototype,"hasRotation",void 0),(0,U._)([(0,q.W)()],k.prototype,"debugDrawLabelBorder",void 0),(0,U._)([(0,q.W)()],k.prototype,"hasPolygonOffset",void 0),(0,U._)([(0,q.W)()],k.prototype,"depthTestEnabled",void 0),(0,U._)([(0,q.W)()],k.prototype,"pixelSnappingEnabled",void 0),(0,U._)([(0,q.W)()],k.prototype,"draped",void 0),(0,U._)([(0,q.W)()],k.prototype,"terrainDepthTest",void 0),(0,U._)([(0,q.W)()],k.prototype,"cullAboveTerrain",void 0),(0,U._)([(0,q.W)()],k.prototype,"occlusionPass",void 0),(0,U._)([(0,q.W)()],k.prototype,"occludedFragmentFade",void 0),(0,U._)([(0,q.W)()],k.prototype,"objectAndLayerIdColorInstanced",void 0),(0,U._)([(0,q.W)()],k.prototype,"horizonCullingEnabled",void 0),(0,U._)([(0,q.W)()],k.prototype,"isFocused",void 0);var Q=i(75569);class Z extends P.im{constructor(e,t){super(e,Ae),this.produces=new Map([[T.N.HUD_MATERIAL,e=>(0,S.Mb)(e)&&!this.parameters.drawAsLabel],[T.N.LABEL_MATERIAL,e=>(0,S.Mb)(e)&&this.parameters.drawAsLabel],[T.N.OCCLUSION_PIXELS,()=>this.parameters.occlusionTest],[T.N.DRAPED_MATERIAL,e=>this.parameters.draped&&(0,S.Mb)(e)]]),this._visible=!0,this._configuration=new k(t)}getConfiguration(e,t){const i=this.parameters.draped;return super.getConfiguration(e,t,this._configuration),this._configuration.hasSlicePlane=this.parameters.hasSlicePlane,this._configuration.hasVerticalOffset=!!this.parameters.verticalOffset,this._configuration.hasScreenSizePerspective=!!this.parameters.screenSizePerspective,this._configuration.screenCenterOffsetUnitsEnabled="screen"===this.parameters.centerOffsetUnits,this._configuration.hasPolygonOffset=this.parameters.polygonOffset,this._configuration.draped=i,this._configuration.occlusionTestEnabled=this.parameters.occlusionTest,this._configuration.pixelSnappingEnabled=this.parameters.pixelSnappingEnabled,this._configuration.signedDistanceFieldEnabled=this.parameters.textureIsSignedDistanceField,this._configuration.sampleSignedDistanceFieldTexelCenter=this.parameters.sampleSignedDistanceFieldTexelCenter,this._configuration.hasRotation=this.parameters.hasRotation,this._configuration.vvSize=!!this.parameters.vvSize,this._configuration.vvColor=!!this.parameters.vvColor,this._configuration.occlusionPass=t.slot===T.N.OCCLUSION_PIXELS,this._configuration.occludedFragmentFade=!i&&this.parameters.occludedFragmentFade,this._configuration.horizonCullingEnabled=this.parameters.horizonCullingEnabled,this._configuration.isFocused=this.parameters.isFocused,this._configuration.depthTestEnabled=this.parameters.depthEnabled||t.slot===T.N.OCCLUSION_PIXELS,(0,S.RN)(e)&&(this._configuration.debugDrawLabelBorder=!!A.b.LABELS_SHOW_BORDER),this._configuration.oitPass=t.oitPass,this._configuration.terrainDepthTest=t.terrainDepthTest,this._configuration.cullAboveTerrain=t.cullAboveTerrain,this._configuration}intersect(e,t,i,n,o,a){const{options:{selectionMode:l,hud:c,excludeLabels:d},point:h,camera:v}=i,{parameters:g}=this;if(!l||!c||d&&g.isLabel||!e.visible||!h||!v)return;const m=e.attributes.get(y.r.FEATUREATTRIBUTE),A=null==m?null:(0,p.ci)(m.data,fe),{scaleX:x,scaleY:S}=be(A,g,v.pixelRatio);(0,r.z0)(ae,t),e.attributes.has(y.r.FEATUREATTRIBUTE)&&function(e){const t=e[0],i=e[1],n=e[2],o=e[3],r=e[4],a=e[5],s=e[6],l=e[7],c=e[8],d=1/Math.sqrt(t*t+i*i+n*n),u=1/Math.sqrt(o*o+r*r+a*a),f=1/Math.sqrt(s*s+l*l+c*c);e[0]=t*d,e[1]=i*d,e[2]=n*d,e[3]=o*u,e[4]=r*u,e[5]=a*u,e[6]=s*f,e[7]=l*f,e[8]=c*f}(ae);const C=e.attributes.get(y.r.POSITION),b=e.attributes.get(y.r.SIZE),O=e.attributes.get(y.r.NORMAL),P=e.attributes.get(y.r.ROTATION),T=e.attributes.get(y.r.CENTEROFFSETANDDISTANCE);(0,z.vA)(C.size>=3);const I=(0,_.c)(g),F="screen"===this.parameters.centerOffsetUnits;for(let r=0;r<C.data.length/C.size;r++){const e=r*C.size;(0,u.i)(K,C.data[e],C.data[e+1],C.data[e+2]),(0,u.t)(K,K,t),(0,u.t)(K,K,v.viewMatrix);const n=r*T.size;if((0,u.i)(de,T.data[n],T.data[n+1],T.data[n+2]),!F&&(K[0]+=de[0],K[1]+=de[1],0!==de[2])){const e=de[2];(0,u.n)(de,K),(0,u.d)(K,K,(0,u.g)(de,de,e))}const o=r*O.size;if((0,u.i)(ee,O.data[o],O.data[o+1],O.data[o+2]),X(ee,ae,v,pe),Oe(this.parameters,K,pe,v,J),v.applyProjection(K,te),te[0]>-1){F&&(de[0]||de[1])&&(te[0]+=de[0]*v.pixelRatio,0!==de[1]&&(te[1]+=(0,E.m0)(de[1],J.factorAlignment)*v.pixelRatio),v.unapplyProjection(te,K)),te[0]+=this.parameters.screenOffset[0]*v.pixelRatio,te[1]+=this.parameters.screenOffset[1]*v.pixelRatio,te[0]=Math.floor(te[0]),te[1]=Math.floor(te[1]);const e=r*b.size;ge[0]=b.data[e],ge[1]=b.data[e+1],(0,E.MD)(ge,J.factor,ge);const t=he*v.pixelRatio;let n=0;g.textureIsSignedDistanceField&&(n=Math.min(g.outlineSize,.5*ge[0])*v.pixelRatio/2),ge[0]*=x,ge[1]*=S;const o=r*P.size,l=g.rotation+P.data[o];if($(h,te[0],te[1],ge,t,n,l,g,I)){const e=i.ray;if((0,u.t)(ne,K,(0,s.B8)(le,v.viewMatrix)),te[0]=h[0],te[1]=h[1],v.unprojectFromRenderScreen(te,K)){const t=(0,f.vt)();(0,u.c)(t,e.direction);const i=1/(0,u.l)(t);(0,u.g)(t,t,i),a((0,u.j)(e.origin,K)*i,t,-1,ne)}}}}}intersectDraped(e,t,i,n,o){const r=e.attributes.get(y.r.POSITION),a=e.attributes.get(y.r.SIZE),s=e.attributes.get(y.r.ROTATION),l=this.parameters,c=(0,_.c)(l),d=e.attributes.get(y.r.FEATUREATTRIBUTE),u=null==d?null:(0,p.ci)(d.data,fe),{scaleX:f,scaleY:h}=be(u,l,e.screenToWorldRatio),v=ve*e.screenToWorldRatio;for(let p=0;p<r.data.length/r.size;p++){const t=p*r.size,d=r.data[t],u=r.data[t+1],g=p*a.size;ge[0]=a.data[g],ge[1]=a.data[g+1];let m=0;l.textureIsSignedDistanceField&&(m=Math.min(l.outlineSize,.5*ge[0])*e.screenToWorldRatio/2),ge[0]*=f,ge[1]*=h;const A=p*s.size,x=l.rotation+s.data[A];$(i,d,u,ge,v,m,x,l,c)&&n(o.distance,o.normal,-1)}}createBufferWriter(){return new Ce}applyShaderOffsetsView(e,t,i,n,o,r,a){const s=X(t,i,o,pe);return this._applyVerticalGroundOffsetView(e,s,o,a),Oe(this.parameters,a,s,o,r),this._applyPolygonOffsetView(a,s,n[3],o,a),this._applyCenterOffsetView(a,n,a),a}applyShaderOffsetsNDC(e,t,i,n,o){return this._applyCenterOffsetNDC(e,t,i,n),null!=o&&(0,u.c)(o,n),this._applyPolygonOffsetNDC(n,t,i,n),n}_applyPolygonOffsetView(e,t,i,n,r){const a=n.aboveGround?1:-1;let s=Math.sign(i);0===s&&(s=a);const l=a*s;if(this.parameters.shaderPolygonOffset<=0)return(0,u.c)(r,e);const c=(0,o.qE)(Math.abs(t.cosAngle),.01,1),d=1-Math.sqrt(1-c*c)/c/n.viewport[2];return(0,u.g)(r,e,l>0?d:1/d),r}_applyVerticalGroundOffsetView(e,t,i,n){const o=(0,u.l)(e),r=i.aboveGround?1:-1,a=i.computeRenderPixelSizeAtDist(o)*C.R,s=(0,u.g)(K,t.normal,r*a);return(0,u.f)(n,e,s),n}_applyCenterOffsetView(e,t,i){const n="screen"!==this.parameters.centerOffsetUnits;return i!==e&&(0,u.c)(i,e),n&&(i[0]+=t[0],i[1]+=t[1],t[2]&&((0,u.n)(ee,i),(0,u.a)(i,i,(0,u.g)(ee,ee,t[2])))),i}_applyCenterOffsetNDC(e,t,i,n){const o="screen"!==this.parameters.centerOffsetUnits;return n!==e&&(0,u.c)(n,e),o||(n[0]+=t[0]/i.fullWidth*2,n[1]+=t[1]/i.fullHeight*2),n}_applyPolygonOffsetNDC(e,t,i,n){const o=this.parameters.shaderPolygonOffset;if(e!==n&&(0,u.c)(n,e),o){const e=i.aboveGround?1:-1,r=e*Math.sign(t[3]);n[2]-=(r||e)*o}return n}set visible(e){this._visible=e}get visible(){const{color:e,outlineSize:t,outlineColor:i}=this.parameters,n=e[3]>=Q.Q||t>=Q.Q&&i[3]>=Q.Q;return this._visible&&n}createGLMaterial(e){return new G(e)}calculateRelativeScreenBounds(e,t){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:(0,v.vt)();return function(e,t,i,n){n[0]=e.anchorPosition[0]*-t[0]+e.screenOffset[0]*i,n[1]=e.anchorPosition[1]*-t[1]+e.screenOffset[1]*i}(this.parameters,e,t,i),i[2]=i[0]+e[0],i[3]=i[1]+e[1],i}}class G extends O.m8{constructor(e){super((0,n.A)((0,n.A)({},e),e.material.parameters))}beginSlot(e){return this.updateTexture(this._material.parameters.textureId),this._material.setParameters(this.textureBindParameters),this.getTechnique(M,e)}}function X(e,t,i,n){return h(t)&&(t=(0,r.z0)(se,t)),(0,u.o)(n.normal,e,t),(0,u.t)(n.normal,n.normal,i.viewInverseTransposeMatrix),n.cosAngle=(0,u.e)(ie,me),n}function $(e,t,i,n,r,a,s,l,d){let u=t-r-n[0]*d[0],f=u+n[0]+2*r,p=i-r-n[1]*d[1],h=p+n[1]+2*r;const v=l.distanceFieldBoundingBox;return l.textureIsSignedDistanceField&&null!=v&&(u+=n[0]*v[0],p+=n[1]*v[1],f-=n[0]*(1-v[2]),h-=n[1]*(1-v[3]),u-=a,f+=a,p-=a,h+=a),(0,c.hZ)(re,t,i),(0,c.e$)(oe,e,re,(0,o.kU)(s)),oe[0]>u&&oe[0]<f&&oe[1]>p&&oe[1]<h}const J=new class{constructor(){this.factor=new I,this.factorAlignment=new I}},K=(0,f.vt)(),ee=(0,f.vt)(),te=(0,p.vt)(),ie=(0,f.vt)(),ne=(0,f.vt)(),oe=(0,d.vt)(),re=(0,d.vt)(),ae=(0,a.vt)(),se=(0,a.vt)(),le=(0,l.vt)(),ce=(0,p.vt)(),de=(0,f.vt)(),ue=(0,f.vt)(),fe=(0,p.vt)(),pe={normal:ie,cosAngle:0},he=1,ve=2,ge=(0,d.fA)(0,0),me=(0,f.fA)(0,0,1);class Ae extends O.NV{constructor(){super(...arguments),this.renderOccluded=P.m$.Occlude,this.isDecoration=!1,this.color=(0,p.CN)(1,1,1,1),this.polygonOffset=!1,this.anchorPosition=(0,d.fA)(.5,.5),this.screenOffset=[0,0],this.shaderPolygonOffset=1e-5,this.textureIsSignedDistanceField=!1,this.sampleSignedDistanceFieldTexelCenter=!1,this.outlineColor=(0,p.CN)(1,1,1,1),this.outlineSize=0,this.distanceFieldBoundingBox=(0,p.vt)(),this.rotation=0,this.hasRotation=!1,this.vvSizeEnabled=!1,this.vvSize=null,this.vvColor=null,this.vvOpacity=null,this.vvSymbolAnchor=null,this.vvSymbolRotationMatrix=null,this.hasSlicePlane=!1,this.pixelSnappingEnabled=!0,this.occlusionTest=!0,this.occludedFragmentFade=!1,this.horizonCullingEnabled=!1,this.centerOffsetUnits="world",this.drawAsLabel=!1,this.depthEnabled=!0,this.isFocused=!0,this.focusStyle="bright",this.draped=!1,this.isLabel=!1}}const xe=(0,x.BP)().vec3f(y.r.POSITION).vec3f(y.r.NORMAL).vec2i16(y.r.UVI).vec4u8(y.r.COLOR).vec2f(y.r.SIZE).f32(y.r.ROTATION).vec4f(y.r.CENTEROFFSETANDDISTANCE).vec4f(y.r.FEATUREATTRIBUTE),Se=xe.clone().vec4u8(y.r.OLIDCOLOR);class Ce{constructor(){this.vertexBufferLayout=(0,b.E)()?Se:xe}elementCount(e){return 6*e.get(y.r.POSITION).indices.length}write(e,t,i,n,o,r){var a;const{position:s,normal:l,uvi:c,color:d,size:u,rotation:f,centerOffsetAndDistance:p,featureAttribute:h}=o;(0,F.Hk)(i.get(y.r.POSITION),e,s,r,6),(0,F.p1)(i.get(y.r.NORMAL),t,l,r,6);const v=null===(a=i.get(y.r.UVI))||void 0===a?void 0:a.data;let m=0,A=0,x=-1-_.f,S=-1-_.f;v&&v.length>=4&&(m=v[0],A=v[1],x=-1-v[2],S=-1-v[3]);let C=i.get(y.r.POSITION).indices.length,b=r;for(let g=0;g<C;++g)c.set(b,0,m),c.set(b,1,A),b++,c.set(b,0,x),c.set(b,1,A),b++,c.set(b,0,x),c.set(b,1,S),b++,c.set(b,0,x),c.set(b,1,S),b++,c.set(b,0,m),c.set(b,1,S),b++,c.set(b,0,m),c.set(b,1,A),b++;(0,F.tb)(i.get(y.r.COLOR),4,d,r,6);const{data:O,indices:P}=i.get(y.r.SIZE);C=P.length,b=r;for(let g=0;g<C;++g){const e=O[2*P[g]],t=O[2*P[g]+1];for(let i=0;i<6;++i)u.set(b,0,e),u.set(b,1,t),b++}if((0,F.uO)(i.get(y.r.ROTATION),f,r,6),i.get(y.r.CENTEROFFSETANDDISTANCE)?(0,F.Ut)(i.get(y.r.CENTEROFFSETANDDISTANCE),p,r,6):(0,F.Pq)(p,r,6*C),i.get(y.r.FEATUREATTRIBUTE)?(0,F.Ut)(i.get(y.r.FEATUREATTRIBUTE),h,r,6):(0,F.Pq)(h,r,6*C),null!=n){var T;const e=null===(T=i.get(y.r.POSITION))||void 0===T?void 0:T.indices;if(e){const t=e.length,i=o.getField(y.r.OLIDCOLOR,g.XP);(0,F.vx)(n,i,t,r,6)}}return{numVerticesPerItem:6,numItems:C}}intersect(e,t,i,n,o,r,a){const{options:{selectionMode:l,hud:c,excludeLabels:d},point:p,camera:h}=n;if(!l||!c||d&&t.isLabel||!p)return;const v=this.vertexBufferLayout.createView(e),m=v.getField(y.r.POSITION,g.xs),A=v.getField(y.r.NORMAL,g.xs),x=v.getField(y.r.ROTATION,g.Y$),S=v.getField(y.r.SIZE,g.gH),C=v.getField(y.r.FEATUREATTRIBUTE,g.Eq),b=v.getField(y.r.CENTEROFFSETANDDISTANCE,g.Eq),O="screen"===t.centerOffsetUnits,P=(0,_.c)(t);if(null==m||null==A||null==x||null==S||null==b||null==h)return;const T=null==C?null:C.getVec(0,fe),{scaleX:z,scaleY:I}=be(T,t,h.pixelRatio),F=m.count/6;for(let g=0;g<F;g++){const e=6*g;if(m.getVec(e,K),null!=i&&(0,u.f)(K,K,i),(0,u.t)(K,K,h.viewMatrix),b.getVec(e,ce),(0,u.i)(de,ce[0],ce[1],ce[2]),!O&&(K[0]+=de[0],K[1]+=de[1],0!==de[2])){const e=de[2];(0,u.n)(de,K),(0,u.d)(K,K,(0,u.g)(de,de,e))}if(A.getVec(e,ee),X(ee,ae,h,pe),Oe(t,K,pe,h,J),h.applyProjection(K,te),te[0]>-1){O&&(de[0]||de[1])&&(te[0]+=de[0]*h.pixelRatio,0!==de[1]&&(te[1]+=(0,E.m0)(de[1],J.factorAlignment)*h.pixelRatio),h.unapplyProjection(te,K)),te[0]+=t.screenOffset[0]*h.pixelRatio,te[1]+=t.screenOffset[1]*h.pixelRatio,te[0]=Math.floor(te[0]),te[1]=Math.floor(te[1]),S.getVec(e,ge),(0,E.MD)(ge,J.factor,ge);const i=he*h.pixelRatio;let o=0;t.textureIsSignedDistanceField&&(o=Math.min(t.outlineSize,.5*ge[0])*h.pixelRatio/2),ge[0]*=z,ge[1]*=I;const r=x.get(e),l=t.rotation+r;if($(p,te[0],te[1],ge,i,o,l,t,P)){const e=n.ray;if((0,u.t)(ne,K,(0,s.B8)(le,h.viewMatrix)),te[0]=p[0],te[1]=p[1],h.unprojectFromRenderScreen(te,K)){const t=(0,f.vt)();(0,u.c)(t,e.direction);const i=1/(0,u.l)(t);(0,u.g)(t,t,i),a((0,u.j)(e.origin,K)*i,t,g,ne)}}}}}}function be(e,t,i){return null==e||null==t.vvSize?{scaleX:i,scaleY:i}:((0,m.VC)(ue,t,e),{scaleX:ue[0]*i,scaleY:ue[1]*i})}function Oe(e,t,i,n,o){var r,a;if(null===(r=e.verticalOffset)||void 0===r||!r.screenLength)return e.screenSizePerspective||e.screenSizePerspectiveAlignment?Pe(e,o,(0,u.l)(t),i.cosAngle):(o.factor.scale=1,o.factorAlignment.scale=1),t;const s=(0,u.l)(t),l=null!==(a=e.screenSizePerspectiveAlignment)&&void 0!==a?a:e.screenSizePerspective,c=(0,R.kE)(n,s,e.verticalOffset,i.cosAngle,l);return Pe(e,o,s,i.cosAngle),(0,u.g)(i.normal,i.normal,c),(0,u.f)(t,t,i.normal)}function Pe(e,t,i,n){null!=e.screenSizePerspective?(0,E.cJ)(n,i,e.screenSizePerspective,t.factor):(t.factor.scale=1,t.factor.factor=0,t.factor.minScaleFactor=0),null!=e.screenSizePerspectiveAlignment?(0,E.cJ)(n,i,e.screenSizePerspectiveAlignment,t.factorAlignment):(t.factorAlignment.factor=t.factor.factor,t.factorAlignment.scale=t.factor.scale,t.factorAlignment.minScaleFactor=t.factor.minScaleFactor)}},19061:(e,t,i)=>{i.d(t,{H:()=>Ce,b:()=>ve,c:()=>me,f:()=>xe});var n,o,r,a,s,l,c,d,u,f,p,h,v,g,m,A,x,S,C,b,O,P,T,E,z,y,I,F,R,_,w,D,H,N,j,L=i(57528),M=i(19555),V=i(72745),U=i(55855),B=i(14556),W=i(34981),q=i(26917),Y=i(90080),k=i(98720),Q=i(40318),Z=i(38280),G=i(62374),X=i(87236),$=i(66763),J=i(80883),K=i(81449),ee=i(69817),te=i(42451),ie=i(95756),ne=i(51596),oe=i(20123),re=i(58350),ae=i(23148),se=i(21390),le=i(86955),ce=i(4653),de=i(70367),ue=i(72001),fe=i(66470),pe=i(2687),he=i(75569);function ve(e){const t=new pe.N5,{signedDistanceFieldEnabled:i,occlusionTestEnabled:V,horizonCullingEnabled:ve,pixelSnappingEnabled:xe,hasScreenSizePerspective:Ce,debugDrawLabelBorder:be,vvSize:Oe,vvColor:Pe,hasRotation:Te,occludedFragmentFade:Ee,sampleSignedDistanceFieldTexelCenter:ze}=e;t.include(Q.Q,e),t.vertex.include(q.rA,e);const{occlusionPass:ye,output:Ie,oitPass:Fe}=e;if(ye)return t.include(Z.I,e),t;const{vertex:Re,fragment:_e}=t;t.include(ee.Y6),t.include($.A,e),t.include(Y.g,e),V&&t.include(G.y),_e.include(K.W),_e.include(J.a),t.varyings.add("vcolor","vec4"),t.varyings.add("vtc","vec2"),t.varyings.add("vsize","vec2");const we=Ie===W.V.Highlight,De=we&&V;De&&t.varyings.add("voccluded","float"),Re.uniforms.add(new ne.I("viewport",e=>e.camera.fullViewport),new ie.G("screenOffset",(e,t)=>(0,M.hZ)(Ae,2*e.screenOffset[0]*t.camera.pixelRatio,2*e.screenOffset[1]*t.camera.pixelRatio)),new ie.G("anchorPosition",e=>me(e)),new re.E("materialColor",e=>e.color),new se.m("materialRotation",e=>e.rotation),new de.N("tex",e=>e.texture)),(0,te.Nz)(Re),i&&(Re.uniforms.add(new re.E("outlineColor",e=>e.outlineColor)),_e.uniforms.add(new re.E("outlineColor",e=>ge(e)?e.outlineColor:U.uY),new se.m("outlineSize",e=>ge(e)?e.outlineSize:0))),ve&&Re.uniforms.add(new oe.V("pointDistanceSphere",(e,t)=>{const i=t.camera.eye,n=e.origin;return(0,U.fA)(n[0]-i[0],n[1]-i[1],n[2]-i[2],B.$O.radius)})),xe&&Re.include(k.K),Ce&&((0,ee.pM)(Re),(0,ee.OH)(Re)),be&&t.varyings.add("debugBorderCoords","vec4"),t.attributes.add(fe.r.UVI,"vec2"),t.attributes.add(fe.r.COLOR,"vec4"),t.attributes.add(fe.r.SIZE,"vec2"),t.attributes.add(fe.r.ROTATION,"float"),(Oe||Pe)&&t.attributes.add(fe.r.FEATUREATTRIBUTE,"vec4"),Re.code.add(ve?(0,le.H)(n||(n=(0,L.A)(["bool behindHorizon(vec3 posModel) {\nvec3 camToEarthCenter = pointDistanceSphere.xyz - localOrigin;\nvec3 camToPos = pointDistanceSphere.xyz + posModel;\nfloat earthRadius = pointDistanceSphere.w;\nfloat a = dot(camToPos, camToPos);\nfloat b = dot(camToPos, camToEarthCenter);\nfloat c = dot(camToEarthCenter, camToEarthCenter) - earthRadius * earthRadius;\nreturn b > 0.0 && b < a && b * b  > a * c;\n}"]))):(0,le.H)(o||(o=(0,L.A)(["bool behindHorizon(vec3 posModel) { return false; }"])))),Re.main.add((0,le.H)(r||(r=(0,L.A)(["\n    ProjectHUDAux projectAux;\n    vec4 posProj = projectPositionHUD(projectAux);\n    forwardObjectAndLayerIdColor();\n\n    if (rejectBySlice(projectAux.posModel)) {\n      // Project outside of clip plane\n      gl_Position = vec4(1e038, 1e038, 1e038, 1.0);\n      return;\n    }\n\n    if (behindHorizon(projectAux.posModel)) {\n      // Project outside of clip plane\n      gl_Position = vec4(1e038, 1e038, 1e038, 1.0);\n      return;\n    }\n\n    vec2 inputSize;\n    ","\n    ","\n\n    vec2 combinedSize = inputSize * pixelRatio;\n    vec4 quadOffset = vec4(0.0);\n\n    ","\n    ","\n  "])),(0,le.If)(Ce,(0,le.H)(a||(a=(0,L.A)(["\n        inputSize = screenSizePerspectiveScaleVec2(size, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspective);\n        vec2 screenOffsetScaled = screenSizePerspectiveScaleVec2(screenOffset, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspectiveAlignment);"]))),(0,le.H)(s||(s=(0,L.A)(["\n        inputSize = size;\n        vec2 screenOffsetScaled = screenOffset;"])))),(0,le.If)(Oe,(0,le.H)(l||(l=(0,L.A)(["inputSize *= vvScale(featureAttribute).xx;"])))),(0,le.If)(V,(0,le.H)(c||(c=(0,L.A)(["\n    bool visible = testHUDVisibility(posProj);\n    if (!visible) {\n      vtc = vec2(0.0);\n      ","\n      return;\n    }"])),(0,le.If)(be,"debugBorderCoords = vec4(0.5, 0.5, 1.5 / combinedSize);"))),(0,le.If)(De,(0,le.H)(d||(d=(0,L.A)(["voccluded = visible ? 0.0 : 1.0;"]))))));const He=(0,le.H)(u||(u=(0,L.A)(["\n      vec2 uvi1 = vec2(uvi.x < 0.0 ? 1.0 : 0.0, uvi.y < 0.0 ? 1.0 : 0.0);\n      vec2 uv = abs(uvi + uvi1);\n      vec2 texSize = vec2(textureSize(tex, 0));\n      uv.x = uv.x >= "," ? 1.0 : uv.x / texSize.x;\n      uv.y = uv.y >= "," ? 1.0 : uv.y / texSize.y;\n      quadOffset.xy = (uvi1 - anchorPosition) * 2.0 * combinedSize;\n\n      ","\n\n      quadOffset.xy = (quadOffset.xy + screenOffsetScaled) / viewport.zw * posProj.w;\n  "])),Se,Se,(0,le.If)(Te,(0,le.H)(f||(f=(0,L.A)(["\n          float angle = radians(materialRotation + rotation);\n          float cosAngle = cos(angle);\n          float sinAngle = sin(angle);\n          mat2 rotate = mat2(cosAngle, -sinAngle, sinAngle,  cosAngle);\n\n          quadOffset.xy = rotate * quadOffset.xy;\n        "]))))),Ne=xe?i?(0,le.H)(p||(p=(0,L.A)(["posProj = alignToPixelOrigin(posProj, viewport.zw) + quadOffset;"]))):(0,le.H)(h||(h=(0,L.A)(["posProj += quadOffset;\nif (inputSize.x == size.x) {\nposProj = alignToPixelOrigin(posProj, viewport.zw);\n}"]))):(0,le.H)(v||(v=(0,L.A)(["posProj += quadOffset;"])));Re.main.add((0,le.H)(g||(g=(0,L.A)(["\n    ","\n    ","\n\n    ","\n\n    bool alphaDiscard = vcolor.a < ",";\n    ",'\n    if (alphaDiscard) {\n      // "early discard" if both symbol color (= fill) and outline color (if applicable) are transparent\n      gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\n      return;\n    } else {\n      ',"\n      gl_Position = posProj;\n    }\n\n    vtc = uv;\n\n    ","\n    vsize = inputSize;\n  "])),He,Pe?"vcolor = interpolateVVColor(featureAttribute.y) * materialColor;":"vcolor = color / 255.0 * materialColor;",(0,le.If)(Ie===W.V.ObjectAndLayerIdColor,(0,le.H)(m||(m=(0,L.A)(["vcolor.a = 1.0;"])))),le.H.float(he.Q),(0,le.If)(i,"alphaDiscard = alphaDiscard && outlineColor.a < ".concat(le.H.float(he.Q),";")),Ne,(0,le.If)(be,(0,le.H)(A||(A=(0,L.A)(["debugBorderCoords = vec4(uv01, 1.5 / combinedSize);"])))))),_e.uniforms.add(new de.N("tex",e=>e.texture)),Ee&&!we&&_e.uniforms.add(new ce.x("depthMap",e=>e.mainDepth),new ae.U("occludedOpacity",e=>e.hudOccludedFragmentOpacity));const je=be?(0,le.H)(x||(x=(0,L.A)(["(isBorder > 0.0 ? 0.0 : ",")"])),le.H.float(he.Q)):le.H.float(he.Q),Le=(0,le.H)(S||(S=(0,L.A)(["\n    ","\n\n    vec2 samplePos = vtc;\n\n    ","\n\n    ","\n\n    ","\n\n    ","\n  "])),(0,le.If)(be,(0,le.H)(C||(C=(0,L.A)(["float isBorder = float(any(lessThan(debugBorderCoords.xy, debugBorderCoords.zw)) || any(greaterThan(debugBorderCoords.xy, 1.0 - debugBorderCoords.zw)));"])))),(0,le.If)(ze,(0,le.H)(b||(b=(0,L.A)(["\n      float txSize = float(textureSize(tex, 0).x);\n      float texelSize = 1.0 / txSize;\n\n      // Calculate how much we have to add/subtract to/from each texel to reach the size of an onscreen pixel\n      vec2 scaleFactor = (vsize - txSize) * texelSize;\n      samplePos += (vec2(1.0, -1.0) * texelSize) * scaleFactor;"])))),i?(0,le.H)(O||(O=(0,L.A)(["\n      vec4 fillPixelColor = vcolor;\n\n      // Get distance and map it into [-0.5, 0.5]\n      float d = rgbaTofloat(texture(tex, samplePos)) - 0.5;\n\n      // Distance in output units (i.e. pixels)\n      float dist = d * vsize.x;\n\n      // Create smooth transition from the icon into its outline\n      float fillAlphaFactor = clamp(0.5 - dist, 0.0, 1.0);\n      fillPixelColor.a *= fillAlphaFactor;\n\n      if (outlineSize > 0.25) {\n        vec4 outlinePixelColor = outlineColor;\n        float clampedOutlineSize = min(outlineSize, 0.5*vsize.x);\n\n        // Create smooth transition around outline\n        float outlineAlphaFactor = clamp(0.5 - (abs(dist) - 0.5*clampedOutlineSize), 0.0, 1.0);\n        outlinePixelColor.a *= outlineAlphaFactor;\n\n        if (\n          outlineAlphaFactor + fillAlphaFactor < "," ||\n          fillPixelColor.a + outlinePixelColor.a < ","\n        ) {\n          discard;\n        }\n\n        // perform un-premultiplied over operator (see https://en.wikipedia.org/wiki/Alpha_compositing#Description)\n        float compositeAlpha = outlinePixelColor.a + fillPixelColor.a * (1.0 - outlinePixelColor.a);\n        vec3 compositeColor = vec3(outlinePixelColor) * outlinePixelColor.a +\n          vec3(fillPixelColor) * fillPixelColor.a * (1.0 - outlinePixelColor.a);\n\n        ","\n      } else {\n        if (fillAlphaFactor < ",") {\n          discard;\n        }\n\n        ","\n      }\n\n      // visualize SDF:\n      // fragColor = vec4(clamp(-dist/vsize.x*2.0, 0.0, 1.0), clamp(dist/vsize.x*2.0, 0.0, 1.0), 0.0, 1.0);\n      "])),je,le.H.float(he.Q),(0,le.If)(!we,(0,le.H)(P||(P=(0,L.A)(["fragColor = vec4(compositeColor, compositeAlpha);"])))),je,(0,le.If)(!we,(0,le.H)(T||(T=(0,L.A)(["fragColor = premultiplyAlpha(fillPixelColor);"]))))):(0,le.H)(E||(E=(0,L.A)(["\n          vec4 texColor = texture(tex, samplePos, -0.5);\n          if (texColor.a < ",") {\n            discard;\n          }\n          ","\n          "])),je,(0,le.If)(!we,(0,le.H)(z||(z=(0,L.A)(["fragColor = texColor * premultiplyAlpha(vcolor);"]))))),(0,le.If)(Ee&&!we,(0,le.H)(y||(y=(0,L.A)(["\n        float zSample = texelFetch(depthMap, ivec2(gl_FragCoord.xy), 0).x;\n        if (zSample < gl_FragCoord.z) {\n          fragColor *= occludedOpacity;\n        }\n        "])))),(0,le.If)(!we&&be,(0,le.H)(I||(I=(0,L.A)(["fragColor = mix(fragColor, vec4(1.0, 0.0, 1.0, 1.0), isBorder * 0.5);"])))));switch(Ie){case W.V.Color:case W.V.ColorEmission:t.outputs.add("fragColor","vec4",0),Ie===W.V.ColorEmission&&t.outputs.add("fragEmission","vec4",1),Fe===ue.Y.ColorAlpha&&t.outputs.add("fragAlpha","float",Ie===W.V.ColorEmission?2:1),_e.main.add((0,le.H)(F||(F=(0,L.A)(["\n        ","\n        ","\n        ","\n        ",""])),Le,(0,le.If)(Fe===ue.Y.FrontFace,(0,le.H)(R||(R=(0,L.A)(["fragColor.rgb /= fragColor.a;"])))),(0,le.If)(Ie===W.V.ColorEmission,(0,le.H)(_||(_=(0,L.A)(["fragEmission = vec4(0.0);"])))),(0,le.If)(Fe===ue.Y.ColorAlpha,(0,le.H)(w||(w=(0,L.A)(["fragAlpha = fragColor.a;"]))))));break;case W.V.ObjectAndLayerIdColor:_e.main.add((0,le.H)(D||(D=(0,L.A)(["\n        ","\n        outputObjectAndLayerIdColor();"])),Le));break;case W.V.Highlight:t.include(X.Q,e),_e.main.add((0,le.H)(H||(H=(0,L.A)(["\n        ","\n        outputHighlight(",");"])),Le,(0,le.If)(De,(0,le.H)(N||(N=(0,L.A)(["voccluded == 1.0"]))),(0,le.H)(j||(j=(0,L.A)(["false"]))))))}return t}function ge(e){return e.outlineColor[3]>0&&e.outlineSize>0}function me(e){return e.textureIsSignedDistanceField?(t=e.anchorPosition,i=e.distanceFieldBoundingBox,n=Ae,(0,M.hZ)(n,t[0]*(i[2]-i[0])+i[0],t[1]*(i[3]-i[1])+i[1])):(0,M.C)(Ae,e.anchorPosition),Ae;var t,i,n}const Ae=(0,V.vt)(),xe=32e3,Se=le.H.float(xe),Ce=Object.freeze(Object.defineProperty({__proto__:null,build:ve,calculateAnchorPosition:me,fullUV:xe},Symbol.toStringTag,{value:"Module"}))},38280:(e,t,i)=>{i.d(t,{I:()=>c});var n,o,r=i(57528),a=i(98720),s=i(94192),l=i(86955);function c(e,t){const{vertex:i,fragment:c}=e;e.include(s.Z,t),i.include(a.K),i.main.add((0,l.H)(n||(n=(0,r.A)(["vec4 posProjCenter;\nif (dot(position, position) > 0.0) {\nProjectHUDAux projectAux;\nvec4 posProj = projectPositionHUD(projectAux);\nposProjCenter = alignToPixelCenter(posProj, viewport.zw);\nforwardViewPosDepth(projectAux.posView);\nvec3 vpos = projectAux.posModel;\nif (rejectBySlice(vpos)) {\nposProjCenter = vec4(1e038, 1e038, 1e038, 1.0);\n}\n} else {\nposProjCenter = vec4(1e038, 1e038, 1e038, 1.0);\n}\ngl_Position = posProjCenter;\ngl_PointSize = 1.0;"])))),c.main.add((0,l.H)(o||(o=(0,r.A)(["fragColor = vec4(1);\nif(discardByTerrainDepth()) {\nfragColor.g = 0.5;\n}"]))))}},60216:(e,t,i)=>{i.d(t,{E:()=>r});var n=i(9392),o=(i(9956),i(14487));function r(e,t,i){return!!(0,o.F)(e,t,a,i.spatialReference)&&(i.x=a[0],i.y=a[1],i.z=a[2],!0)}const a=(0,n.vt)()}}]);
//# sourceMappingURL=5011.a44f6a6c.chunk.js.map